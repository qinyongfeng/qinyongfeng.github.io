<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>并发编程的艺术_2</title>
      <link href="/posts/7f17ba45.html"/>
      <url>/posts/7f17ba45.html</url>
      
        <content type="html"><![CDATA[<h5 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h5><p>Java代码在编译后会变成Java字节码，字节码被类加载器加载到JVM里，JVM执行字节码，最终需要转化为汇编指令在CPU上执行，Java中所使用的并发机制依赖于JVM的实现和CPU的指令。本章我们将深入底层一起探索下Java并发机制的底层实现原理。</p><h5 id="2-1-volatile的应用"><a href="#2-1-volatile的应用" class="headerlink" title="2.1 volatile的应用"></a>2.1 volatile的应用</h5><p>在多线程并发编程中<code>synchronized</code>和<code>volatile</code>都扮演着重要的角色，volatile是轻量级的synchronized，它在多处理器开发中保证了共享变量的<code>“可见性”</code>。<code>可见性的意思是当一个线程修改一个共享变量时，另外一个线程能读到这个修改的值。如果volatile变量修饰符使用恰当的话，它比synchronized的使用和执行成本更低，因为它不会引起线程上下文的切换和调度。</code>本文将深入分析在硬件层面上Intel处理器是如何实现volatile的，通过深入分析帮助我们正确地使用volatile变量。<br><strong>1. volatile的定义与实现原理</strong><br>Java语言规范第3版中对volatile的定义如下：<code>Java编程语言允许线程访问共享变量，为了确保共享变量能被准确和一致地更新，线程应该确保通过排他锁单独获得这个变量</code>。Java语言提供了volatile，在某些情况下比锁要更加方便。如果一个字段被声明成volatile，Java线程内存模型确保所有线程看到这个变量的值是一致的。<br>在了解volatile实现原理之前，我们先来看下与其实现原理相关的CPU术语与说明。下图是CPU术语的定义。<br><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://cdn.jsdelivr.net/gh/rryf/images/posts/20210420142733.jpg" alt="CPU的术语定义"></p><p>volatile是如何来保证可见性的呢？让我们在X86处理器下通过工具获取JIT编译器生成的汇编指令来查看对volatile进行写操作时，CPU会做什么事情。</p><pre class="line-numbers language-java"><code class="language-java">instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">//instance是volatile变量</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>转变成汇编代码，如下。</p><pre><code>0x01a3de1d: movb $0×0,0×1104800(%esi);0x01a3de24: lock  addl $0×0,(%esp);</code></pre><p>有volatile变量修饰的共享变量进行写操作的时候会多出第二行汇编代码，通过查IA-32架构软件开发者手册可知，Lock前缀的指令在多核处理器下会引发了两件事</p><ol><li>将当前处理器缓存行的数据写回到系统内存。</li><li>这个写回内存的操作会使在其他CPU里缓存了该内存地址的数据无效。</li></ol><p>为了提高处理速度，处理器不直接和内存进行通信，而是先将系统内存的数据读到内部缓存（L1，L2或其他）后再进行操作，但操作完不知道何时会写到内存。如果对声明了volatile的变量进行写操作，JVM就会向处理器发送一条Lock前缀的指令，将这个变量所在缓存行的数据写回到系统内存。但是，就算写回到内存，如果其他处理器缓存的值还是旧的，再执行计算操作就会有问题。所以，在多处理器下，为了保证各个处理器的缓存是一致的，就会实现缓存一致性协议，每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态，当处理器对这个数据进行修改操作的时候，会重新从系统内存中把数据读到处理器缓存里。</p><p>下面来具体讲解volatile的两条实现原则。</p><ol><li><p><code>Lock前缀指令会引起处理器缓存回写到内存</code>。Lock前缀指令导致在执行指令期间，声言处理器的LOCK#信号。在多处理器环境中，LOCK#信号确保在声言该信号期间，处理器可以独占任何共享内存[插图]。但是，在最近的处理器里，LOCK #信号一般不锁总线，而是锁缓存，毕竟锁总线开销的比较大。在8.1.4节有详细说明锁定操作对处理器缓存的影响，对于Intel486和Pentium处理器，在锁操作时，总是在总线上声言LOCK#信号。但在P6和目前的处理器中，如果访问的内存区域已经缓存在处理器内部，则不会声言LOCK#信号。相反，它会锁定这块内存区域的缓存并回写到内存，并使用缓存一致性机制来确保修改的原子性，此操作被称为“缓存锁定”，缓存一致性机制会阻止同时修改由两个以上处理器缓存的内存区域数据。</p></li><li><p><code>一个处理器的缓存回写到内存会导致其他处理器的缓存无效</code>。IA-32处理器和Intel 64处理器使用MESI（修改、独占、共享、无效）控制协议去维护内部缓存和其他处理器缓存的一致性。在多核处理器系统中进行操作的时候，IA-32和Intel 64处理器能嗅探其他处理器访问系统内存和它们的内部缓存。处理器使用嗅探技术保证它的内部缓存、系统内存和其他处理器的缓存的数据在总线上保持一致。例如，在Pentium和P6 family处理器中，如果通过嗅探一个处理器来检测其他处理器打算写内存地址，而这个地址当前处于共享状态，那么正在嗅探的处理器将使它的缓存行无效，在下次访问相同内存地址时，强制执行缓存行填充。</p><p><strong>2.volatile的使用优化</strong></p></li></ol><p>著名的Java并发编程大师Doug lea在JDK 7的并发包里新增一个队列集合类Linked-TransferQueue，它在使用volatile变量时，用一种追加字节的方式来优化队列出队和入队的性能。LinkedTransferQueue的代码如下。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token operator">/</span>＊＊ 队列中的头部节点 ＊<span class="token operator">/</span><span class="token keyword">private</span> <span class="token keyword">transient</span> <span class="token keyword">final</span> PaddedAtomicReference<span class="token operator">&lt;</span>QNode<span class="token operator">></span> head<span class="token punctuation">;</span><span class="token operator">/</span>＊＊ 队列中的尾部节点 ＊<span class="token operator">/</span><span class="token keyword">private</span> <span class="token keyword">transient</span> <span class="token keyword">final</span> PaddedAtomicReference<span class="token operator">&lt;</span>QNode<span class="token operator">></span> tail<span class="token punctuation">;</span><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">PaddedAtomicReference</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token keyword">extends</span> <span class="token class-name">AtomicReference</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">//使用很多4个字节的引用追加到64个字节</span>  Object p0<span class="token punctuation">,</span> p1<span class="token punctuation">,</span> p2<span class="token punctuation">,</span> p3<span class="token punctuation">,</span> p4<span class="token punctuation">,</span> p5<span class="token punctuation">,</span> p6<span class="token punctuation">,</span> p7<span class="token punctuation">,</span> p8<span class="token punctuation">,</span> p9<span class="token punctuation">,</span> pa<span class="token punctuation">,</span> pb<span class="token punctuation">,</span> pc<span class="token punctuation">,</span> pd<span class="token punctuation">,</span> pe<span class="token punctuation">;</span>  <span class="token function">PaddedAtomicReference</span><span class="token punctuation">(</span>T r<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">super</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AtomicReference</span> <span class="token operator">&lt;</span>V<span class="token operator">></span> <span class="token keyword">implements</span> <span class="token class-name">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>Serializable</span> <span class="token punctuation">{</span>  <span class="token keyword">private</span> <span class="token keyword">volatile</span> V value<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//省略其他代码</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>追加字节能优化性能？</code>这种方式看起来很神奇，但如果深入理解处理器架构就能理解其中的奥秘。让我们先来看看LinkedTransferQueue这个类，它使用一个内部类类型来定义队列的头节点（head）和尾节点（tail），而这个内部类PaddedAtomicReference相对于父类AtomicReference只做了一件事情，就是将共享变量追加到64字节。我们可以来计算下，一个对象的引用占4个字节，它追加了15个变量（共占60个字节），再加上父类的value变量，一共64个字节。</p><p><code>为什么追加64字节能够提高并发编程的效率呢？</code>因为对于英特尔酷睿i7、酷睿、Atom和NetBurst，以及Core Solo和Pentium M处理器的L1、L2或L3缓存的高速缓存行是64个字节宽，不支持部分填充缓存行，这意味着，如果队列的头节点和尾节点都不足64字节的话，处理器会将它们都读到同一个高速缓存行中，在多处理器下每个处理器都会缓存同样的头、尾节点，当一个处理器试图修改头节点时，会将整个缓存行锁定，那么在缓存一致性机制的作用下，会导致其他处理器不能访问自己高速缓存中的尾节点，而队列的入队和出队操作则需要不停修改头节点和尾节点，所以在多处理器的情况下将会严重影响到队列的入队和出队效率。Doug lea使用追加到64字节的方式来填满高速缓冲区的缓存行，避免头节点和尾节点加载到同一个缓存行，使头、尾节点在修改时不会互相锁定。</p><p><code>那么是不是在使用volatile变量时都应该追加到64字节呢？</code>不是的。在两种场景下不应该使用这种方式。</p><ul><li>缓存行非64字节宽的处理器。如P6系列和奔腾处理器，它们的L1和L2高速缓存行是32个字节宽。</li><li>共享变量不会被频繁地写。因为使用追加字节的方式需要处理器读取更多的字节到高速缓冲区，这本身就会带来一定的性能消耗，如果共享变量不被频繁写的话，锁的几率也非常小，就没必要通过追加字节的方式来避免相互锁定。</li></ul><p>不过这种追加字节的方式在Java 7下可能不生效，因为Java 7变得更加智慧，它会淘汰或重新排列无用字段，需要使用其他追加字节的方式。除了volatile，Java并发编程中应用较多的是synchronized，下面一起来看一下。</p><h5 id="2-2-synchronized的实现原理与应用"><a href="#2-2-synchronized的实现原理与应用" class="headerlink" title="2.2 synchronized的实现原理与应用"></a>2.2 synchronized的实现原理与应用</h5><p>在多线程并发编程中synchronized一直是元老级角色，很多人都会称呼它为重量级锁。但是，随着Java SE 1.6对synchronized进行了各种优化之后，有些情况下它就并不那么重了。本文详细介绍Java SE 1.6中为了减少获得锁和释放锁带来的性能消耗而引入的偏向锁和轻量级锁，以及锁的存储结构和升级过程。<br>先来看下利用synchronized实现同步的基础：Java中的每一个对象都可以作为锁。具体表现为以下3种形式。</p><ul><li><code>对于普通同步方法，锁是当前实例对象</code>。</li><li><code>对于静态同步方法，锁是当前类的Class对象</code>。</li><li><code>对于同步方法块，锁是Synchonized括号里配置的对象</code>。</li></ul><p>当一个线程试图访问同步代码块时，它首先必须得到锁，退出或抛出异常时必须释放锁。那么锁到底存在哪里呢？锁里面会存储什么信息呢？</p><p>从JVM规范中可以看到Synchonized在JVM里的实现原理，JVM基于进入和退出Monitor对象来实现方法同步和代码块同步，但两者的实现细节不一样。代码块同步是使用monitorenter和monitorexit指令实现的，而方法同步是使用另外一种方式实现的，细节在JVM规范里并没有详细说明。但是，方法的同步同样可以使用这两个指令来实现。</p><p>monitorenter指令是在编译后插入到同步代码块的开始位置，而monitorexit是插入到方法结束处和异常处，JVM要保证每个monitorenter必须有对应的monitorexit与之配对。任何对象都有一个monitor与之关联，当且一个monitor被持有后，它将处于锁定状态。线程执行到monitorenter指令时，将会尝试获取对象所对应的monitor的所有权，即尝试获得对象的锁。</p><h5 id="2-2-1-Java对象头"><a href="#2-2-1-Java对象头" class="headerlink" title="2.2.1 Java对象头"></a>2.2.1 Java对象头</h5><p>synchronized用的锁是存在Java对象头里的。如果对象是数组类型，则虚拟机用3个字宽（Word）存储对象头，如果对象是非数组类型，则用2字宽存储对象头。在32位虚拟机中，1字宽等于4字节，即32bit，如表下图所示。</p><p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://cdn.jsdelivr.net/gh/rryf/images/posts/20210420144427.jpg" alt="Java对象头的长度"></p><p>Java对象头里的Mark Word里默认存储对象的HashCode、分代年龄和锁标记位。32位JVM的Mark Word的默认存储结构如下图所示。</p><p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://cdn.jsdelivr.net/gh/rryf/images/posts/20210420144523.jpg" alt=" Java对象头的存储结构"></p><p>在运行期间，Mark Word里存储的数据会随着锁标志位的变化而变化。Mark Word可能变化为存储以下4种数据，如表下图所示。</p><p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://cdn.jsdelivr.net/gh/rryf/images/posts/20210420144657.png" alt="Mark Word的状态变化"></p><p>在64位虚拟机下，Mark Word是64bit大小的，其存储结构如下图所示。</p><p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://cdn.jsdelivr.net/gh/rryf/images/posts/20210420144739.png" alt="Mark Word的存储结构"></p><h5 id="2-2-2-锁的升级与对比"><a href="#2-2-2-锁的升级与对比" class="headerlink" title="2.2.2 锁的升级与对比"></a>2.2.2 锁的升级与对比</h5><p>Java SE 1.6为了减少获得锁和释放锁带来的性能消耗，引入了“偏向锁”和“轻量级锁”，在Java SE 1.6中，锁一共有4种状态，级别从低到高依次是：无锁状态、偏向锁状态、轻量级锁状态和重量级锁状态，这几个状态会随着竞争情况逐渐升级。锁可以升级但不能降级，意味着偏向锁升级成轻量级锁后不能降级成偏向锁。这种锁升级却不能降级的策略，目的是为了提高获得锁和释放锁的效率，下文会详细分析。</p><p><strong><code>1.偏向锁</code></strong></p><p>HotSpot[插图] 的作者经过研究发现，大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，为了让线程获得锁的代价更低而引入了偏向锁。当一个线程访问同步块并获取锁时，会在对象头和栈帧中的锁记录里存储锁偏向的线程ID，以后该线程在进入和退出同步块时不需要进行CAS操作来加锁和解锁，只需简单地测试一下对象头的Mark Word里是否存储着指向当前线程的偏向锁。如果测试成功，表示线程已经获得了锁。如果测试失败，则需要再测试一下Mark Word中偏向锁的标识是否设置成1（表示当前是偏向锁）：如果没有设置，则使用CAS竞争锁；如果设置了，则尝试使用CAS将对象头的偏向锁指向当前线程。</p><p><code>（1）偏向锁的撤销</code></p><p>​        偏向锁使用了一种等到竞争出现才释放锁的机制，所以当其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁。偏向锁的撤销，需要等待全局安全点（在这个时间点上没有正在执行的字节码）。它会首先暂停拥有偏向锁的线程，然后检查持有偏向锁的线程是否活着，如果线程不处于活动状态，则将对象头设置成无锁状态；如果线程仍然活着，拥有偏向锁的栈会被执行，遍历偏向对象的锁记录，栈中的锁记录和对象头的Mark Word要么重新偏向于其他线程，要么恢复到无锁或者标记对象不适合作为偏向锁，最后唤醒暂停的线程。下图中的线程1演示了偏向锁初始化的流程，线程2演示了偏向锁撤销的流程。<br><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://cdn.jsdelivr.net/gh/rryf/images/posts/20210420144957.png" alt="偏向锁初始化的流程"><br><code>（2）关闭偏向锁</code><br>​        偏向锁在Java 6和Java 7里是默认启用的，但是它在应用程序启动几秒钟之后才激活，如有必要可以使用JVM参数来关闭延迟：-XX:BiasedLockingStartupDelay=0。如果你确定应用程序里所有的锁通常情况下处于竞争状态，可以通过JVM参数关闭偏向锁：-XX:-UseBiasedLocking=false，那么程序默认会进入轻量级锁状态。<br><strong><code>2.轻量级锁</code></strong><br><code>（1）轻量级锁加锁</code><br>​        线程在执行同步块之前，JVM会先在当前线程的栈桢中创建用于存储锁记录的空间，并将对象头中的Mark Word复制到锁记录中，官方称为Displaced Mark Word。然后线程尝试使用CAS将对象头中的Mark Word替换为指向锁记录的指针。如果成功，当前线程获得锁，如果失败，表示其他线程竞争锁，当前线程便尝试使用自旋来获取锁。</p><p><code>（2）轻量级锁解锁</code><br>​        轻量级解锁时，会使用原子的CAS操作将Displaced Mark Word替换回到对象头，如果成功，则表示没有竞争发生。如果失败，表示当前锁存在竞争，锁就会膨胀成重量级锁。下图是两个线程同时争夺锁，导致锁膨胀的流程图。<br><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://cdn.jsdelivr.net/gh/rryf/images/posts/20210420145145.png" alt="争夺锁导致的锁膨胀流程图"></p><p>因为自旋会消耗CPU，为了避免无用的自旋（比如获得锁的线程被阻塞住了），一旦锁升级成重量级锁，就不会再恢复到轻量级锁状态。当锁处于这个状态下，其他线程试图获取锁时，都会被阻塞住，当持有锁的线程释放锁之后会唤醒这些线程，被唤醒的线程就会进行新一轮的夺锁之争。</p><p><strong><code>3.锁的优缺点对比</code></strong></p><p>下图是锁的优缺点的对比。</p><p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://cdn.jsdelivr.net/gh/rryf/images/posts/20210420145502.png" alt=" 锁的优缺点的对比"></p><h5 id="2-3-原子操作的实现原理"><a href="#2-3-原子操作的实现原理" class="headerlink" title="2.3 原子操作的实现原理"></a>2.3 原子操作的实现原理</h5><p>原子（atomic）本意是“不能被进一步分割的最小粒子”，而原子操作（atomicoperation）意为“不可被中断的一个或一系列操作”。在多处理器上实现原子操作就变得有点复杂。让我们一起来聊一聊在Intel处理器和Java里是如何实现原子操作的。</p><p><strong><code>1.术语定义</code></strong></p><p>在了解原子操作的实现原理前，先要了解一下相关的术语，如下图所示。</p><p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://cdn.jsdelivr.net/gh/rryf/images/posts/20210420145746.png" alt="CPU术语定义"></p><p><strong>2.处理器如何实现原子操作</strong></p><p>32位IA-32处理器使用基于对缓存加锁或总线加锁的方式来实现多处理器之间的原子操作。首先处理器会自动保证基本的内存操作的原子性。处理器保证从系统内存中读取或者写入一个字节是原子的，意思是当一个处理器读取一个字节时，其他处理器不能访问这个字节的内存地址。Pentium 6和最新的处理器能自动保证单处理器对同一个缓存行里进行16/32/64位的操作是原子的，但是复杂的内存操作处理器是不能自动保证其原子性的，比如跨总线宽度、跨多个缓存行和跨页表的访问。但是，处理器提供总线锁定和缓存锁定两个机制来保证复杂内存操作的原子性。</p><p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://cdn.jsdelivr.net/gh/rryf/images/posts/20210420145830.png" alt="结果对比"></p><p><code>（1）使用总线锁保证原子性</code></p><p>​    <strong>第一个机制是通过总线锁保证原子性</strong>。如果多个处理器同时对共享变量进行读改写操作（i++就是经典的读改写操作），那么共享变量就会被多个处理器同时进行操作，这样读改写操作就不是原子的，操作完之后共享变量的值会和期望的不一致。举个例子，如果i=1，我们进行两次i++操作，我们期望的结果是3，但是有可能结果是2，如上图所示。</p><p>原因可能是多个处理器同时从各自的缓存中读取变量i，分别进行加1操作，然后分别写入系统内存中。那么，想要保证读改写共享</p><p>变量的操作是原子的，就必须保证CPU1读改写共享变量的时候，CPU2不能操作缓存了该共享变量内存地址的缓存。</p><p>处理器使用总线锁就是来解决这个问题的。所谓总线锁就是使用处理器提供的一个LOCK #信号，当一个处理器在总线上输出此信号时，其他处理器的请求将被阻塞住，那么该处理器可以独占共享内存。</p><p><code>（2）使用缓存锁保证原子性</code></p><p>​    <strong>第二个机制是通过缓存锁定来保证原子性</strong>。在同一时刻，我们只需保证对某个内存地址的操作是原子性即可，但总线锁定把CPU和内存之间的通信锁住了，这使得锁定期间，其他处理器不能操作其他内存地址的数据，所以总线锁定的开销比较大，目前处理器在某些场合下使用缓存锁定代替总线锁定来进行优化。</p><p>频繁使用的内存会缓存在处理器的L1、L2和L3高速缓存里，那么原子操作就可以直接在处理器内部缓存中进行，并不需要声明总线锁，在Pentium 6和目前的处理器中可以使用“缓存锁定”的方式来实现复杂的原子性。所谓“缓存锁定”是指内存区域如果被缓存在处理器的缓存行中，并且在Lock操作期间被锁定，那么当它执行锁操作回写到内存时，处理器不在总线上声言LOCK #信号，而是修改内部的内存地址，并允许它的缓存一致性机制来保证操作的原子性，因为缓存一致性机制会阻止同时修改由两个以上处理器缓存的内存区域数据，当其他处理器回写已被锁定的缓存行的数据时，会使缓存行无效，在如图2-3所示的例子中，当CPU1修改缓存行中的i时使用了缓存锁定，那么CPU2就不能同时缓存i的缓存行。</p><p><strong>但是有两种情况下处理器不会使用缓存锁定。</strong></p><p>第一种情况是：当操作的数据不能被缓存在处理器内部，或操作的数据跨多个缓存行（cache line）时，则处理器会调用总线锁定。</p><p>第二种情况是：有些处理器不支持缓存锁定。对于Intel 486和Pentium处理器，就算锁定的内存区域在处理器的缓存行中也会调用总线锁定。</p><p>针对以上两个机制，我们通过Intel处理器提供了很多Lock前缀的指令来实现。例如，位测试和修改指令：BTS、BTR、BTC；交换指令XADD、CMPXCHG，以及其他一些操作数和逻辑指令（如ADD、OR）等，被这些指令操作的内存区域就会加锁，导致其他处理器不能同时访问它。</p><p><strong>3. Java如何实现原子操作</strong></p><p>在Java中可以通过锁和循环CAS的方式来实现原子操作。</p><p><code>（1）使用循环CAS实现原子操作</code></p><p>JVM中的CAS操作正是利用了处理器提供的CMPXCHG指令实现的。自旋CAS实现的基本思路就是循环进行CAS操作直到成功为止，以下代码实现了一个基于CAS线程安全的计数器方法safeCount和一个非线程安全的计数器count。</p><pre><code>private AtomicInteger atomicI = new AtomicInteger(0);    private int i = 0;    public static void main(String[] args) {        final Counter cas = new Counter();        List&lt;Thread&gt; ts = new ArrayList&lt;Thread&gt;(600);        long start = System.currentTimeMillis();        for (int j = 0; j &lt; 100; j++) {              Thread t = new Thread(new Runnable() {                  @Override                  public void run() {                        for (int i = 0; i &lt; 10000; i++) {                            cas.count();                            cas.safeCount();                        }                  }              });              ts.add(t);        }        for (Thread t : ts) {              t.start();        }        //等待所有线程执行完成        for (Thread t : ts) {              try {                  t.join();              } catch (InterruptedException e) {                  e.printStackTrace();              }          }          System.out.println(cas.i);          System.out.println(cas.atomicI.get());          System.out.println(System.currentTimeMillis() - start);      }      /**        * 使用CAS实现线程安全计数器        */      private void safeCount() {          for (;;) {              int i = atomicI.get();              boolean suc = atomicI.compareAndSet(i, ++i);              if (suc) {                  break;              }          }      }      /**       * 非线程安全计数器       */      private void count() {        i++;      }</code></pre><p>从Java 1.5开始，JDK的并发包里提供了一些类来支持原子操作，如AtomicBoolean（用原子方式更新的boolean值）、AtomicInteger（用原子方式更新的int值）和AtomicLong（用原子方式更新的long值）。这些原子包装类还提供了有用的工具方法，比如以原子的方式将当前值自增1和自减1。</p><p><code>（2）CAS实现原子操作的三大问题</code></p><p>在Java并发包中有一些并发框架也使用了自旋CAS的方式来实现原子操作，比如LinkedTransferQueue类的Xfer方法。CAS虽然很高效地解决了原子操作，但是CAS仍然存在三大问题。ABA问题，循环时间长开销大，以及只能保证一个共享变量的原子操作。</p><p>1）<strong>ABA问题</strong>。因为CAS需要在操作值的时候，检查值有没有发生变化，如果没有发生变化则更新，但是如果一个值原来是A，变成了B，又变成了A，那么使用CAS进行检查时会发现它的值没有发生变化，但是实际上却变化了。ABA问题的解决思路就是使用版本号。在变量前面追加上版本号，每次变量更新的时候把版本号加1，那么A→B→A就会变成1A→2B→3A。从Java 1.5开始，JDK的Atomic包里提供了一个类AtomicStampedReference来解决ABA问题。这个类的compareAndSet方法的作用是首先检查当前引用是否等于预期引用，并且检查当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。</p><pre><code>//参数代表的含义分别是 期望值，写入的新值，期望标记，新标记值public boolean compareAndSet(V expected,V newReference,int expectedStamp,int newStamp);public V getRerference();public int getStamp();public void set(V newReference,int newStamp);</code></pre><p><strong>2）循环时间长开销大。</strong>自旋CAS如果长时间不成功，会给CPU带来非常大的执行开销。如果JVM能支持处理器提供的pause指令，那么效率会有一定的提升。pause指令有两个作用：第一，它可以延迟流水线执行指令（de-pipeline），使CPU不会消耗过多的执行资源，延迟的时间取决于具体实现的版本，在一些处理器上延迟时间是零；第二，它可以避免在退出循环的时候因内存顺序冲突（Memory OrderViolation）而引起CPU流水线被清空（CPU Pipeline Flush），从而提高CPU的执行效率。</p><p><strong>3）只能保证一个共享变量的原子操作。</strong>当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候就可以用锁。还有一个取巧的办法，就是把多个共享变量合并成一个共享变量来操作。比如，有两个共享变量i=2,j=a，合并一下ij=2a，然后用CAS来操作ij。从Java 1.5开始，JDK提供了AtomicReference类来保证引用对象之间的原子性，就可以把多个变量放在一个对象里来进行CAS操作。</p><p><code>（3）使用锁机制实现原子操作</code></p><p>锁机制保证了只有获得锁的线程才能够操作锁定的内存区域。JVM内部实现了很多种锁机制，有偏向锁、轻量级锁和互斥锁。有意思的是除了偏向锁，JVM实现锁的方式都用了循环CAS，即当一个线程想进入同步块的时候使用循环CAS的方式来获取锁，当它退出同步块的时候使用循环CAS释放锁。</p><p>2.4 小结</p><p><code>volatile</code>、<code>synchronized</code>和原子操作的实现原理，Java中的大部分容器和框架都依赖于本章介绍的volatile和原子操作的实现原理，</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 并发篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并发编程 </tag>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并发编程的艺术_1</title>
      <link href="/posts/498cfd8e.html"/>
      <url>/posts/498cfd8e.html</url>
      
        <content type="html"><![CDATA[<h3 id="并发编程的艺术-1"><a href="#并发编程的艺术-1" class="headerlink" title="并发编程的艺术_1"></a>并发编程的艺术_1</h3><h4 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h4><p>并发编程的目的是为了让程序运行得更快，但是，<code>并不是启动更多的线程就能让程序最大限度地并发执行</code>。在进行并发编程时，如果希望通过多线程执行任务让程序运行得更快，会面临非常多的挑战，比如上下文切换的问题、死锁的问题，以及受限于硬件和软件的资源限制问题，本章会介绍几种并发编程的挑战以及解决方案。</p><h5 id="1-1上下文切换"><a href="#1-1上下文切换" class="headerlink" title="1.1上下文切换"></a>1.1上下文切换</h5><p>即使是单核处理器也支持多线程执行代码，<code>CPU通过给每个线程分配CPU时间片来实现这个机制。时间片是CPU分配给各个线程的时间，因为时间片非常短，所以CPU通过不停地切换线程执行，让我们感觉多个线程是同时执行的</code>，时间片一般是几十毫秒（ms）。<br>CPU通过时间片分配算法来循环执行任务，当前任务执行一个时间片后会切换到下一个任务。但是，在切换前会保存上一个任务的状态，以便下次切换回这个任务时，可以再加载这个任务的状态。所以任务从保存到再加载的过程就是一次上下文切换。<br><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://cdn.jsdelivr.net/gh/rryf/images/posts/20210420104053.jpg" alt="image"><br><code>创建状态</code>：进程在创建时需要申请一个空白PCB，向其中填写控制和管理进程的信息，完成资源分配。如果创建工作无法完成，比如资源无法满足，就无法被调度运行，把此时进程所处状态称为创建状态<br><code>就绪状态</code>：进程已经准备好，已分配到所需资源，只要分配到CPU就能够立即运行<br><code>执行状态</code>：进程处于就绪状态被调度后，进程进入执行状态<br><code>阻塞状态</code>：正在执行的进程由于某些事件（I/O请求，申请缓存区失败）而暂时无法运行，进程受到<br><code>终止状态</code>：进程结束，或出现错误，或被系统终止，进入终止状态。无法再执行</p><p><code>举例：</code>这就像我们同时读两本书，当我们在读一本英文的技术书时，发现某个单词不认识，于是便打开中英文字典，但是在放下英文技术书之前，大脑必须先记住这本书读到了多少页的第多少行，等查完单词之后，能够继续读这本书。这样的切换是会影响读书效率的，同样上下文切换也会影响多线程的执行速度。</p><h5 id="1-1-1-多线程一定快吗"><a href="#1-1-1-多线程一定快吗" class="headerlink" title="1.1.1 多线程一定快吗"></a>1.1.1 多线程一定快吗</h5><p>下面的代码演示串行和并发执行并累加操作的时间，请分析：下面的代码并发执行一定比串行执行快吗？</p><pre class="line-numbers language-JAVA"><code class="language-JAVA">package dome;public class ConcurrencyTest {    private static final long count = 10000l;    public static void main(String[] args) throws InterruptedException {              concurrency();              serial();    }    private static void concurrency() throws InterruptedException {              long start = System.currentTimeMillis();              Thread thread = new Thread(new Runnable() {                @Override                public void run() {                      int a = 0;                      for (long i = 0; i < count; i++) {                                a += 5;                      }                }              });              thread.start();              int b = 0;              for (long i = 0; i < count; i++) {                        b--;              }              long time = System.currentTimeMillis() - start;              thread.join();              System.out.println("concurrency :" + time+"ms,b="+b);    }    private static void serial() {              long start = System.currentTimeMillis();              int a = 0;              for (long i = 0; i < count; i++) {                        a += 5;              }              int b = 0;              for (long i = 0; i < count; i++) {                        b--;              }              long time = System.currentTimeMillis() - start;              System.out.println("serial:" + time+"ms,b="+b+",a="+a);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果：</p><pre class="line-numbers language-java"><code class="language-java">concurrency <span class="token operator">:</span>1ms<span class="token punctuation">,</span>b<span class="token operator">=</span><span class="token operator">-</span><span class="token number">10000</span>serial<span class="token operator">:</span>0ms<span class="token punctuation">,</span>b<span class="token operator">=</span><span class="token operator">-</span><span class="token number">10000</span><span class="token punctuation">,</span>a<span class="token operator">=</span><span class="token number">50000</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>上述问题的答案是“不一定”，测试结果如表1-1所示。</p><p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://cdn.jsdelivr.net/gh/rryf/images/posts/20210420105230.jpg" alt="image"></p><p><code>总结</code>：</p><p>​        当并发执行累加操作不超过百万次时，速度会比串行执行累加操作要慢。那么，为什么并发执行的速度会比串行慢呢？这是因为线程<code>有创建和上下文切换的开销</code>。</p><h5 id="1-1-2-测试上下文切换次数和时长"><a href="#1-1-2-测试上下文切换次数和时长" class="headerlink" title="1.1.2 测试上下文切换次数和时长"></a>1.1.2 测试上下文切换次数和时长</h5><p>可以度量上下文切换带来的消耗的工具：</p><ul><li>使用Lmbench可以测量上下文切换的时长</li><li>使用vmstat可以测量上下文切换的次数</li></ul><p>vmstat测量上下文切换次数的示例</p><p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://cdn.jsdelivr.net/gh/rryf/images/posts/20210420105717.jpg" alt=""></p><p><code>CS（Content Switch）</code>表示上下文切换的次数，从上面的测试结果中我们可以看到，上下文每1秒切换1000多次。</p><h5 id="1-1-3-如何减少上下文切换"><a href="#1-1-3-如何减少上下文切换" class="headerlink" title="1.1.3 如何减少上下文切换"></a>1.1.3 如何减少上下文切换</h5><p>减少上下文切换的方法有无锁并发编程、CAS算法、使用最少线程和使用协程。</p><ul><li><code>无锁并发编程</code>。多线程竞争锁时，会引起上下文切换，所以多线程处理数据时，可以用一些办法来避免使用锁，如将数据的ID按照Hash算法取模分段，不同的线程处理不同段的数据。</li><li><code>CAS算法</code>。Java的Atomic包使用CAS算法来更新数据，而不需要加锁。</li><li><code>使用最少线程</code>。避免创建不需要的线程，比如任务很少，但是创建了很多线程来处理，这样会造成大量线程都处于等待状态。</li><li><code>协程</code>：在单线程里实现多任务的调度，并在单线程里维持多个任务间的切换。</li></ul><h5 id="1-1-4-减少上下文切换实战"><a href="#1-1-4-减少上下文切换实战" class="headerlink" title="1.1.4 减少上下文切换实战"></a>1.1.4 减少上下文切换实战</h5><p>本节将通过减少线上大量WAITING的线程，来减少上下文切换次数。</p><p><strong>第一步</strong>：用jstack命令dump线程信息，看看pid为3117的进程里的线程都在做什么。（不会使用<code>jstack</code>自行百度，jdk自带工具）</p><p>生成dump文件</p><pre class="line-numbers language-Linux"><code class="language-Linux">sudo -u admin /opt/ifeve/java/bin/jstack 31177 >/home/tengfei.fangtf/dump17<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>第二步</strong>：统计所有线程分别处于什么状态，发现300多个线程处于<code>WAITING</code>（onobject-monitor）状态。</p><pre class="line-numbers language-Linux"><code class="language-Linux">grep java.lang.Thread.State dump17 | awk '{print $2$3$4$5}' | sort | uniq -c<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>结果：</p><pre><code>39 RUNNABLE21 TIMED_WAITING(onobjectmonitor)6 TIMED_WAITING(parking)51 TIMED_WAITING(sleeping)305 WAITING(onobjectmonitor)3 WAITING(parking)</code></pre><p><strong>第三步</strong>：打开dump文件查看处于WAITING（onobjectmonitor）的线程在做什么。发现这些线程基本全是JBOSS的工作线程，在await。说明JBOSS线程池里线程接收到的任务太少，大量线程都闲着。</p><pre><code>"http-0.0.0.0-7001-97" daemon prio=10 tid=0x000000004f6a8000 nid=0x555e in    Object.wait() [0x0000000052423000]java.lang.Thread.State: WAITING (on object monitor)at java.lang.Object.wait(Native Method)- waiting on &lt;0x00000007969b2280&gt; (a org.apache.tomcat.util.net.AprEndpoint$Worker)at java.lang.Object.wait(Object.java:485)at org.apache.tomcat.util.net.AprEndpoint$Worker.await(AprEndpoint.java:1464)- locked &lt;0x00000007969b2280&gt; (a org.apache.tomcat.util.net.AprEndpoint$Worker)at org.apache.tomcat.util.net.AprEndpoint$Worker.run(AprEndpoint.java:1489)at java.lang.Thread.run(Thread.java:662)</code></pre><p><strong>第四步</strong>：减少JBOSS的工作线程数，找到JBOSS的线程池配置信息，将maxThreads降到100。</p><pre><code>&lt;maxThreads="250" maxHttpHeaderSize="8192" emptySessionPath="false" minSpareThreads="40" maxSpareThreads="75" maxPostSize="512000" protocol="HTTP/1.1"  enableLookups="false" redirectPort="8443" acceptCount="200" bufferSize="16384" connectionTimeout="15000" disableUploadTimeout="false" useBodyEncodingForURI="true"&gt;</code></pre><p><strong>第五步</strong>：重启JBOSS，再dump线程信息，然后统计WAITING（onobjectmonitor）的线程，发现减少了175个。WAITING的线程少了，系统上下文切换的次数就会少，因为每一次从WAITTING到RUNNABLE都会进行一次上下文的切换。读者也可以使用vmstat命令测试一下。</p><pre class="line-numbers language-Linux"><code class="language-Linux">grep java.lang.Thread.State dump17 | awk '{print $2$3$4$5}' | sort | uniq -c<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>结果：</p><pre><code>44 RUNNABLE22 TIMED_WAITING(onobjectmonitor)9 TIMED_WAITING(parking)36 TIMED_WAITING(sleeping)130 WAITING(onobjectmonitor)1 WAITING(parking)</code></pre><h5 id="1-2-死锁"><a href="#1-2-死锁" class="headerlink" title="1.2 死锁"></a>1.2 死锁</h5><p>锁是个非常有用的工具，运用场景非常多，因为它使用起来非常简单，而且易于理解。但同时它也会带来一些困扰，那就是可能会引起死锁，一旦产生死锁，就会造成系统功能不可用。让我们先来看一段代码，这段代码会引起死锁，使线程t1和线程t2互相等待对方释放锁。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">package</span> dome<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DeadLockDemo</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> String A <span class="token operator">=</span> <span class="token string">"A"</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> String B <span class="token operator">=</span> <span class="token string">"B"</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>              <span class="token keyword">new</span> <span class="token class-name">DeadLockDemo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">deadLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">deadLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>              Thread t1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token annotation punctuation">@Override</span>                    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                              <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>A<span class="token punctuation">)</span> <span class="token punctuation">{</span>                                      <span class="token keyword">try</span> <span class="token punctuation">{</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                                      <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                                                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                                      <span class="token punctuation">}</span>                                      <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>B<span class="token punctuation">)</span> <span class="token punctuation">{</span>                                                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                                      <span class="token punctuation">}</span>                              <span class="token punctuation">}</span>                    <span class="token punctuation">}</span>              <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>              Thread t2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        <span class="token annotation punctuation">@Override</span>                        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                                  <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>B<span class="token punctuation">)</span> <span class="token punctuation">{</span>                                          <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>A<span class="token punctuation">)</span> <span class="token punctuation">{</span>                                            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                                    <span class="token punctuation">}</span>                          <span class="token punctuation">}</span>                <span class="token punctuation">}</span>      <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      t1<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      t2<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果：</p><p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://cdn.jsdelivr.net/gh/rryf/images/posts/20210420112009.jpg" alt=""></p><p>这段代码只是演示死锁的场景，在现实中你可能不会写出这样的代码。但是，在一些更为复杂的场景中，你可能会遇到这样的问题，比如t1拿到锁之后，因为一些异常情况没有释放锁（死循环）。又或者是t1拿到一个数据库锁，释放锁的时候抛出了异常，没释放掉。一旦出现死锁，业务是可感知的，因为不能继续提供服务了，那么只能通过dump线程查看到底是哪个线程出现了问题，以下线程信息告诉我们是DeadLockDemo类的第42行和第31行引起的死锁。</p><p>一旦出现死锁，业务是可感知的，因为不能继续提供服务了，那么只能通过dump线程查看到底是哪个线程出现了问题，以下线程信息告诉我们是DeadLockDemo类的第42行和第31行引起的死锁。</p><p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://cdn.jsdelivr.net/gh/rryf/images/posts/20210420112214.png" alt=""></p><p>现在我们介绍避免死锁的几个常见方法。</p><ul><li>避免一个线程同时获取多个锁。</li><li>避免一个线程在锁内同时占用多个资源，尽量保证每个锁只占用一个资源。</li><li>尝试使用定时锁，使用lock.tryLock（timeout）来替代使用内部锁机制。</li><li>对于数据库锁，加锁和解锁必须在一个数据库连接里，否则会出现解锁失败的情况。</li></ul><h5 id="1-3-资源限制的挑战"><a href="#1-3-资源限制的挑战" class="headerlink" title="1.3 资源限制的挑战"></a>1.3 资源限制的挑战</h5><h5 id="1-3-1-什么是资源限制"><a href="#1-3-1-什么是资源限制" class="headerlink" title="1.3.1 什么是资源限制"></a>1.3.1 什么是资源限制</h5><p>资源限制是指在进行并发编程时，程序的执行速度受限于计算机硬件资源或软件资源。例如，服务器的带宽只有2Mb/s，某个资源的下载速度是1Mb/s每秒，系统启动10个线程下载资源，下载速度不会变成10Mb/s，所以在进行并发编程时，要考虑这些资源的限制。硬件资源限制有带宽的上传/下载速度、硬盘读写速度和CPU的处理速度。软件资源限制有数据库的连接数和socket连接数等。</p><h5 id="1-3-2-资源限制引发的问题"><a href="#1-3-2-资源限制引发的问题" class="headerlink" title="1.3.2 资源限制引发的问题"></a>1.3.2 资源限制引发的问题</h5><p>在并发编程中，将代码执行速度加快的原则是将代码中串行执行的部分变成并发执行，但是如果将某段串行的代码并发执行，因为受限于资源，仍然在串行执行，这时候程序不仅不会加快执行，反而会更慢，因为增加了上下文切换和资源调度的时间。例如，之前看到一段程序使用多线程在办公网并发地下载和处理数据时，导致CPU利用率达到100%，几个小时都不能运行完成任务，后来修改成单线程，一个小时就执行完成了。</p><h5 id="1-3-3-如何解决资源限制的问题"><a href="#1-3-3-如何解决资源限制的问题" class="headerlink" title="1.3.3 如何解决资源限制的问题"></a>1.3.3 如何解决资源限制的问题</h5><p>在并发编程中，将代码执行速度加快的原则是将代码中串行执行的部分变成并发执行，但是如果将某段串行的代码并发执行，因为受限于资源，仍然在串行执行，这时候程序不仅不会加快执行，反而会更慢，因为增加了上下文切换和资源调度的时间。例如，之前看到一段程序使用多线程在办公网并发地下载和处理数据时，导致CPU利用率达到100%，几个小时都不能运行完成任务，后来修改成单线程，一个小时就执行完成了。</p><p>对于软件资源限制，可以考虑使用资源池将资源复用。比如使用连接池将数据库和Socket连接复用，或者在调用对方webservice接口获取数据时，只建立一个连接</p><h5 id="1-3-4-在资源限制情况下进行并发编程"><a href="#1-3-4-在资源限制情况下进行并发编程" class="headerlink" title="1.3.4 在资源限制情况下进行并发编程"></a>1.3.4 在资源限制情况下进行并发编程</h5><p>如何在资源限制的情况下，让程序执行得更快呢？方法就是，根据不同的资源限制调整程序的并发度，比如下载文件程序依赖于两个资源——带宽和硬盘读写速度。有数据库操作时，涉及数据库连接数，如果SQL语句执行非常快，而线程的数量比数据库连接数大很多，则某些线程会被阻塞，等待数据库连接。</p><p><strong>1.4 小结</strong></p><p>有的并发程序写得不严谨，在并发下如果出现问题，定位起来会比较耗时和棘手。所以，对于Java开发工程师而言，笔者强烈建议多使用JDK并发包提供的并发容器和工具类来解决并发问题，因为这些类都已经通过了充分的测试和优化</p><h5 id="参考文献："><a href="#参考文献：" class="headerlink" title="参考文献："></a>参考文献：</h5><p>Java并发编程的艺术</p><p>原文链接：<a href="https://blog.csdn.net/cafucwxy/article/details/78453430" target="_blank" rel="noopener">https://blog.csdn.net/cafucwxy/article/details/78453430</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 并发篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并发编程 </tag>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo之渲染绕过</title>
      <link href="/posts/17fd92ae.html"/>
      <url>/posts/17fd92ae.html</url>
      
        <content type="html"><![CDATA[<h3 id="1-1-Hexo-渲染"><a href="#1-1-Hexo-渲染" class="headerlink" title="1.1 Hexo 渲染"></a>1.1 Hexo 渲染</h3><p>  在Hexo部署时会默认渲染source下的所有html页面，但有时候想在Hexo博客上单独自定义html页面或README.md时，却不希望被Hexo渲染。因此对某个文件或者目录进行排除渲染是非常必要的。</p><h3 id="1-2-方法一：font-matter"><a href="#1-2-方法一：font-matter" class="headerlink" title="1.2 方法一：font matter"></a>1.2 方法一：font matter</h3><p><code>Hexo</code>新建网站页面，然后将你的代码直接写入 <code>index.md</code> 中</p><p>在 <code>Front matter</code> 中添加 <code>layout: false</code>，此方法适用于单一的纯<code>HTML</code><br><code>CSS</code> 页面。</p><pre class="line-numbers language-bash"><code class="language-bash">---title: toolsdate: 2020-04-28 00:00:00type: <span class="token string">"tools"</span>layout: <span class="token boolean">false</span>---<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-3-方法二：skip-render"><a href="#1-3-方法二：skip-render" class="headerlink" title="1.3 方法二：skip render"></a>1.3 方法二：skip render</h3><p>在博客根目录下的 <code>_config.yml</code>，找到 <code>skip_render</code>，大概在32行左右，写入你想要的跳过渲染的路径，注意缩进和空格。</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 指定目录跳过hexo渲染</span>skip_render:  - <span class="token string">'tools/*'</span>  - <span class="token string">'tools/**'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>注释：<code>tools/*</code> 表示在目录 <code>source/fireworks</code> 下的文件全部跳过渲染，<code>tools/**</code> 表示在博客根目录 <code>source/tools/</code> 文件夹下的文件全部跳过渲染（例如页面的 js、css 在另一个文件夹中）。</p></blockquote><h3 id="1-4-案例：webstack-导航"><a href="#1-4-案例：webstack-导航" class="headerlink" title="1.4 案例：webstack 导航"></a>1.4 案例：webstack 导航</h3><p><code>webstack</code>是一个纯静态的网址导航网站，内容均由<code>viggo</code>收集并整理。项目基于<code>bootstrap</code>前端框架开发。</p><p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://camo.githubusercontent.com/41111c4c1d9922982f380566e6a2f8415204c52c/687474703a2f2f7777772e776562737461636b2e63632f6173736574732f696d616765732f707265766965772e676966" alt="image"></p><ul><li>Github：<a href="https://github.com/WebStackPage/WebStackPage.github.io" target="_blank" rel="noopener">https://github.com/WebStackPage/WebStackPage.github.io</a></li></ul><p>在博客根目录 <code>source/</code>下新建<code>tools</code>，然后新建<code>index.html</code>,将<code>webstack</code>网页源码全选复制粘贴到里面。</p><ul><li>本站的webstack源码：<a href="view-source:http://rryf.top/tools/" target="_blank" rel="noopener">view-source:http://rryf.top/tools/</a></li></ul><blockquote><p>注意：将源码里的部分信息以及跳转链接按照你真实个人博客的环境进行修改。</p></blockquote><p>然后打开博客根目录下配置文件<code>_config.yml</code>，找到<code>skip_render</code>，做如下修改：</p><pre class="line-numbers language-bash"><code class="language-bash">skip_render:  - <span class="token string">'tools/*'</span>  - <span class="token string">'tools/**'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>最后执行<code>hexo clean</code>和<code>hexo s -g</code>本地预览，检查无误后<code>hexo g -d</code>部署到服务器上即可。</p><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><ul><li><a href="http://luckyzmj.cn/posts/17fd92ae.html" target="_blank" rel="noopener">http://luckyzmj.cn/posts/17fd92ae.html</a></li></ul><p>、</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> BLOG篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> 渲染绕过 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>阿里云服务器部署Hexo博客</title>
      <link href="/posts/19d2a4e6.html"/>
      <url>/posts/19d2a4e6.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><hr><p>  相信大部分人使用Hexo搭建个人博客都会部署到一些免费的代码托管平台上，但这些免费的平台总是差强人意，比如国外的GitHub平台虽然完全免费，但在国内访问加载速度非常慢，又或者是国内的码云平台免费版有许多功能被阉割掉了，比如不能自定义域名，不能每次自动刷新提交的代码，需要到码云平台上手动刷新，如此一来非常繁琐。</p><p>  为了有效解决上诉的一些问题，有条件的话，不妨在自己的云服务器上搭建Hexo博客。</p><h2 id="效果演示"><a href="#效果演示" class="headerlink" title="效果演示"></a>效果演示</h2><hr><p>这是Hexo博客部署到GitHub上的网站测速效果</p><p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://cdn.jsdelivr.net/gh/rryf/images/posts/20210419142312.jpg" alt="演示demo1"></p><p>这是Hexo博客部署到阿里云服务器后的网站测速效果</p><p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://cdn.jsdelivr.net/gh/rryf/images/posts/20210419142117.jpg" alt="演示demo2"></p><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><hr><ul><li>本地环境：Windows 10 </li><li>云服务器环境：阿里云ECS（CentOS7.x）</li></ul><h2 id="开始部署"><a href="#开始部署" class="headerlink" title="开始部署"></a>开始部署</h2><hr><h3 id="本地环境搭建"><a href="#本地环境搭建" class="headerlink" title="本地环境搭建"></a>本地环境搭建</h3><p><strong>1.安装Git</strong></p><p>到git官网上下载.exe文件,Download git,安装选项还是全部默认，最后一步添加路径时选择<code>Use Git from the Windows Command Prompt</code>。</p><ul><li>Git<a href="https://git-scm.com/download" target="_blank" rel="noopener">下载地址</a></li><li>Git<a href="https://www.liaoxuefeng.com/wiki/896043488029600" target="_blank" rel="noopener">教程</a></li></ul><p><strong>2.安装Nodejs</strong></p><p>到<a href="http://nodejs.cn/download/" target="_blank" rel="noopener">Node.js官网</a>下载<code>.exe</code>文件，安装选项全部默认。安装好之后，按<code>Win+R</code>打开cmd命令提示符，输入<code>node -v</code>和<code>npm -v</code>，若出现版本号，则说明安装成功。</p><p>使用npm阿里的国内镜像进行加速下载</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">npm</span> config <span class="token keyword">set</span> registry https://registry.npm.taobao.org<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>4.安装Hexo</strong></p><p>先创建一个文件夹<code>MyBlog</code>，用来存放自己的博客文件，然后<code>cd</code>到这个文件夹下（或者在这个文件夹下直接右键<code>git bash here</code>打开）。</p><p>定位到该目录下，输入<code>npm install -g hexo-cli</code>安装<code>Hexo</code>。可能会有几个报错，不用理会。</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> -g hexo-cli<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>安装完后输入<code>hexo -v</code>,若出现版本号则，说明安装成功。</p><p>接下来初始化一下<code>hexo</code>,即初始化我们的博客，输入<code>hexo init</code>初始化文件夹</p><pre class="line-numbers language-bash"><code class="language-bash">hexo init MyBlog<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>新建完成后，指定文件夹<code>MyBlog</code>目录下有：</p><ul><li><code>node_modules</code>: 依赖包</li><li><code>public</code>：存放生成的页面</li><li><code>scaffolds</code>：生成文章的一些模板</li><li><code>source</code>：用来存放你的文章</li><li><code>themes</code>：主题**</li><li><code>_config.yml</code>: 博客的配置文件**</li></ul><p>输入<code>hexo g</code>生成静态网页，然后输入<code>hexo s</code>打开本地服务器预览</p><pre class="line-numbers language-bash"><code class="language-bash">hexo ghexo s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://s1.ax1x.com/2020/03/12/8VdlGD.png" alt="Hexo"></p><h3 id="生成ssh公钥"><a href="#生成ssh公钥" class="headerlink" title="生成ssh公钥"></a>生成ssh公钥</h3><p>在本地桌面点击右键<code>Git Bash Here</code>打开Git终端，执行如下命令`,一路回车</p><pre class="line-numbers language-bash"><code class="language-bash">ssh-keygen -t rsa<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这个时候它会告诉你已经生成了<code>.ssh</code>的文件夹。在<code>git bash</code>中输入</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">cat</span> ~/.ssh/id_rsa.pub<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>输出的内容就是公钥信息了</p><h3 id="阿里云服务器环境搭建"><a href="#阿里云服务器环境搭建" class="headerlink" title="阿里云服务器环境搭建"></a>阿里云服务器环境搭建</h3><p>安装<code>Git</code></p><pre class="line-numbers language-bash"><code class="language-bash">yum <span class="token function">install</span> <span class="token function">git</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>创建<code>Git</code>账户</p><pre class="line-numbers language-bash"><code class="language-bash">adduser <span class="token function">git</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>添加账户权限</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">chmod</span> 740 /etc/sudoersvim /etc/sudoers<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>找到</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true">## Allow root to run any commands anywhere</span>root    ALL<span class="token operator">=</span><span class="token punctuation">(</span>ALL<span class="token punctuation">)</span>     ALL<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>添加以下内容</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">git</span>   ALL<span class="token operator">=</span><span class="token punctuation">(</span>ALL<span class="token punctuation">)</span>     ALL<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>保存退出并改回权限</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">chmod</span> 400 /etc/sudoers<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>设置<code>git</code>账户密码</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">passwd</span> <span class="token function">git</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>切换至<code>git</code>用户，创建 <code>~/.ssh</code> 文件夹和 <code>~/.ssh/authorized_keys</code> 文件，并赋予相应的权限</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">su</span> <span class="token function">git</span><span class="token function">mkdir</span> ~/.sshvim ~/.ssh/authorized_keys<span class="token comment" spellcheck="true"># 然后将win10中生成的id_rsa.pub文件中的公钥复制到authorized_keys</span><span class="token function">chmod</span> 600 /home/git/.ssh/authorized_keys<span class="token function">chmod</span> 700 /home/git/.ssh<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在本地<code>Git</code>终端中测试是否能免密登录<code>git</code>，其中<code>SERVER</code>为填写自己的云主机<code>IP</code>，执行输入<code>yes</code>后不用密码就说明好了</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">ssh</span> -v git@SERVER<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>创建目录</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true">#repo作为为Git仓库目录</span><span class="token function">mkdir</span> /var/repo<span class="token function">chown</span> -R git:git /var/repo<span class="token function">chmod</span> -R 755 /var/repo<span class="token comment" spellcheck="true">#hexo作为网站根目录</span><span class="token function">mkdir</span> /var/www/hexo<span class="token function">chown</span> -R git:git /var/www/hexo<span class="token function">chmod</span> -R 755 /var/www/hexo<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后创建一个裸的 <code>Git</code> 仓库</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">cd</span> var/repo<span class="token function">git</span> init --bare hexoBlog.git<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>创建一个新的 <code>Git</code> 钩子，用于自动部署 在 <code>/var/repo/hexoBlog.git</code> 下，有一个自动生成的 <code>hooks</code> 文件夹。我们需要在里边新建一个新的钩子文件 <code>post-receive</code>。</p><pre class="line-numbers language-bash"><code class="language-bash">vim /var/repo/hexoBlog.git/hooks/post-receive<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>按 <code>i</code> 键进入文件的编辑模式，在该文件中添加两行代码（将下边的代码粘贴进去)，指定 <code>Git</code> 的工作树（源代码）和 <code>Git</code> 目录（配置文件等）</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span><span class="token function">git</span> --work-tree<span class="token operator">=</span>/var/www/hexo --git-dir<span class="token operator">=</span>/var/repo/hexoBlog.git checkout -f<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>然后，按 <code>Esc</code> 键退出编辑模式，输入”<code>:wq</code>” 保存退出。</p><p>修改文件权限，使得其可执行</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">chown</span> -R git:git /var/repo/hexoBlog.git/hooks/post-receive<span class="token function">chmod</span> +x /var/repo/hexoBlog.git/hooks/post-receive<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>到此为止 <code>Git</code> 仓库就搭建完成了。</p><h3 id="阿里云服务器配置Nginx"><a href="#阿里云服务器配置Nginx" class="headerlink" title="阿里云服务器配置Nginx"></a>阿里云服务器配置Nginx</h3><p>用宝塔面板来一键部署Nginx <code>Linux</code>面板6.0安装命令(暂时仅兼容<code>Centos7.x</code>，其它系统版本请安装5.9稳定版)：</p><pre class="line-numbers language-bash"><code class="language-bash">yum <span class="token function">install</span> -y <span class="token function">wget</span> <span class="token operator">&amp;&amp;</span> <span class="token function">wget</span> -O install.sh http://download.bt.cn/install/install_6.0.sh <span class="token operator">&amp;&amp;</span> <span class="token function">bash</span> install.sh<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>Linux</code>面板6.0升级专业版</p><pre class="line-numbers language-bash"><code class="language-bash">curl http://download.bt.cn/install/update6.sh<span class="token operator">|</span><span class="token function">bash</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>安装完成后会显示面板后台地址·账号·密码。打开面板后台地址登陆面板，选择<code>Nginx</code>的部署方案，静静等待部署。</p><p>部署完成，点击网站-添加站点-输入域名(没有域名的输入自己的<code>IP</code>地址)-底部的<code>PHP</code>版本选择”纯静态”-提交。 </p><p>网站创建完成后点击设置-配置文件</p><pre class="line-numbers language-bash"><code class="language-bash">server<span class="token punctuation">{</span>    listen 80<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true"># server_name 填写自己的域名</span>    server_name luckyzmj.cn blog.luckyzmj.cn<span class="token punctuation">;</span>    index index.php index.html index.htm default.php default.htm default.html<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true"># 这里root填写自己的网站根目录，修改为/var/www/hexo</span>    root /var/www/hexo<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>-保存</p><p>点击设置-网站目录，修改为<code>/var/www/hexo</code> ，保存</p><p>重启宝塔面板服务</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">service</span> bt restart<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="本地Hexo部署到阿里云服务器"><a href="#本地Hexo部署到阿里云服务器" class="headerlink" title="本地Hexo部署到阿里云服务器"></a>本地Hexo部署到阿里云服务器</h3><p>进入到本地<code>Hexo</code>博客的文件夹<code>MyBlog</code>,右键点击<code>Git Bash Here</code>，输入命令</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true">#定义邮箱(更换为你的邮箱地址就行)</span><span class="token function">git</span> config --global user.email <span class="token string">"you@example.com"</span><span class="token comment" spellcheck="true">#定义名称(更换自定义一个名称就行)</span><span class="token function">git</span> config --global user.name <span class="token string">"Your Name"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>配置<code>_config.yml</code>,完成自动化部署 </p><p>打开本地<code>Hexo</code>博客的文件夹<code>MyBlog</code>文件夹下的<code>_config.yml</code>, 找到<code>deploy</code></p><pre class="line-numbers language-bash"><code class="language-bash">deploy:  type: <span class="token function">git</span>  <span class="token comment" spellcheck="true">#server改为你的服务IP地址或解析后的域名</span>  <span class="token comment" spellcheck="true">#例如我改为repo: git@luckyzmj.cn:/var/repo/blog.git</span>  repo: git@server:/var/repo/blog.git  branch: master<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>保存后，即可测试部署</p><p>再进入到本地<code>Hexo</code>博客的文件夹<code>MyBlog</code>,右键点击<code>Git Bash Here</code>，输入命令</p><pre class="line-numbers language-bash"><code class="language-bash">hexo clean hexo g -d<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>不报错说明完成，打开浏览器输入你的域名或<code>ip</code>地址就可以看到你部署的<code>Hexo</code>博客了。 </p><p>到此为止，我们已经成功部完成，并且访问自己的服务器端比访问Github快多了。</p><blockquote><h3 id="小贴士"><a href="#小贴士" class="headerlink" title="小贴士"></a>小贴士</h3></blockquote><p>在部署过程中，执行 hexo d发现部署老是出错，什么权限不允许之类的，这里我们需要检查我们在上述的<code>git</code>操作部署是否使用了<code>git</code>用户操作，若是没有，需要给相应的目录更改用户组 使用</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">chown</span> -R git:git /var/repo/<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这条命令递归的将<code>repo</code>目录及其子目录用户组设置为<code>git</code>。 同时使用</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">chown</span> -R git:git /var/www/hexo<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这样即可解决此类问题。</p><p>还有一个问题就是绑定域名后不能访问。原因是在国内任何域名只要绑定到国内的服务器主机上都必须去工信部和公安部备案完后才能正常使用。如果是港澳台的服务器或者是国外的服务器则可以不需要备案。</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><a href="https://blog.csdn.net/weixin_33907511/article/details/91398208?utm_source=distribute.pc_relevant.none-task" target="_blank" rel="noopener">https://blog.csdn.net/weixin_33907511/article/details/91398208?utm_source=distribute.pc_relevant.none-task</a></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> BLOG篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> 阿里云 </tag>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PicGo+GitHub 图床搭建</title>
      <link href="/posts/7a46f93c.html"/>
      <url>/posts/7a46f93c.html</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>用GitHub搭建图床，在很久之前我就有了解，但由于市面上有挺多免费的图床，比如我之前一直在用的 路过图床，所以一直懒得动手搭建GitHub图床。一直到前两天我在完善博客的相册时，发现 路过图床 免费版的有这么多限制，比如：每小时限制上传50张图片，每天限制上传100张图片，而且免费版用户的存储容量貌似不过300M，这才意识到有一个自己的GitHub图床是多么重要。</p><h3 id="一-、PicGO-介绍"><a href="#一-、PicGO-介绍" class="headerlink" title="一 、PicGO 介绍"></a>一 、PicGO 介绍</h3><p>PicGo是一款图片上传工具，目前支持 SM.MS图床、腾讯云COS、GitHub图床、七牛图床、Imgur图床、阿里云OSS、又拍云图床，未来将支持更多图床。</p><p>在支持的这些图床中，SM.MS和Imgur有免费版和收费版，免费版的肯定有很多的使用限制，比如每小时限制上传次数，限制用户的上传容量等等；腾讯云COS、阿里云、有拍云都是要收费使用的；七牛云貌似前期使用免费，后期又要收费才能使用，就剩下的GitHub才是免费且最可靠的。</p><p>PicGo源项目GitHub地址已给出，但是去GitHub下载速度非常慢，这里额外提供一个百度云盘的快速下载地址。</p><ul><li>GitHub地址：<a href="https://github.com/Molunerfinn/PicGo" target="_blank" rel="noopener">https://github.com/Molunerfinn/PicGo</a></li><li>百度云盘地址：<a href="https://pan.baidu.com/s/176ybvTuRUbgsnE7VIZvN_Q" target="_blank" rel="noopener">https://pan.baidu.com/s/176ybvTuRUbgsnE7VIZvN_Q</a>   提取码:  jz7k</li></ul><h3 id="二、-GitHub-图床"><a href="#二、-GitHub-图床" class="headerlink" title="二、 GitHub 图床"></a>二、 GitHub 图床</h3><h4 id="1-创建GitHub图床仓库"><a href="#1-创建GitHub图床仓库" class="headerlink" title="1. 创建GitHub图床仓库"></a>1. 创建GitHub图床仓库</h4><p>首先需要有一个登录GitHub的账号，没有的话去<a href="https://github.com/" target="_blank" rel="noopener">GitHub官网</a>注册一个</p><p>创建一个新的图床仓库，点击右上角的New repository</p><p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://cdn.jsdelivr.net/gh/rryf/images/posts/20210419111832.jpg" alt=""></p><p>填写如下配置信息，然后Create创建仓库</p><p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://cdn.jsdelivr.net/gh/rryf/images/posts/20210419112347.jpg" alt=""></p><h4 id="2-获取GitHub-token值"><a href="#2-获取GitHub-token值" class="headerlink" title="2. 获取GitHub token值"></a>2. 获取GitHub token值</h4><p>点击右上的头像，选择设置Setting</p><p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://cdn.jsdelivr.net/gh/rryf/images/posts/20210419112458.jpg" alt=""></p><p>点击选择Developer settings </p><p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://cdn.jsdelivr.net/gh/rryf/images/posts/20210419112626.jpg" alt=""></p><p>点击 Generate New token</p><p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://cdn.jsdelivr.net/gh/rryf/images/posts/20210419112709.jpg" alt=""></p><p>填写如下配置信息，只要勾选repo选项即可，然后页面拉到底部点击Generate token 即可</p><p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://cdn.jsdelivr.net/gh/rryf/images/posts/20210419112856.jpg" alt=""></p><p>此时会跳转到带有token的页面，将token值复制记录下来，之后用PicGo绑定GitHub图床时会利用到</p><p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://cdn.jsdelivr.net/gh/rryf/images/posts/20210419112950.jpg" alt=""></p><h3 id="三、-PicGo-配置"><a href="#三、-PicGo-配置" class="headerlink" title="三、 PicGo 配置"></a>三、 PicGo 配置</h3><h4 id="1-绑定GitHub图床"><a href="#1-绑定GitHub图床" class="headerlink" title="1. 绑定GitHub图床"></a>1. 绑定GitHub图床</h4><p>首先下载安装好PicGo软件，然后在右列表找到GitHub图床配置</p><p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://cdn.jsdelivr.net/gh/rryf/images/posts/20210419133713.jpg" alt=""></p><p><strong>1. 设定仓库名(必填)：</strong> </p><p>按照“GitHub账户名/仓库名的格式填写”，比如我的是：Luckyzmj/imgbed</p><p><strong>2. 设定分支名(必填)：</strong> </p><p>分支名统一填写“master”</p><p><strong>3. 设定Token(必填)：</strong> </p><p>将之前步骤的Token值复制粘贴到这里</p><p><strong>4. 指定存储路径：</strong> </p><p>这个选项可以为空，如果想将图片上传到仓库的指定目录下，可以填写目录名加/，比如我的imgbed仓库下有个posts文件夹，需设置为 posts/</p><p><strong>5. 设定自定义域名：</strong> </p><p>这里统一用jsdelivr的CDN加速域名，在上传图片后成功后，PicGo会将“自定义域名+上传的图片名”生成的访问链接</p><pre><code>自定义域名格式：https://cdn.jsdelivr.net/gh/GitHub账户名/仓库名以我的格式为例：https://cdn.jsdelivr.net/gh/rryf/images</code></pre><p>配置完全部信息后，点击 设为默认图床，最后点击确定即可</p><h4 id="2-上传图片到图床"><a href="#2-上传图片到图床" class="headerlink" title="2. 上传图片到图床"></a>2. 上传图片到图床</h4><p>在上传区上传图片，可支持本地图片上传(可多选图片)、剪贴板上传、URL上传等三种方式。上传图片成功后，选择你想要生成的图片链接格式</p><p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://cdn.jsdelivr.net/gh/rryf/images/posts/20210419134257.jpg" alt=""></p><p>在图片区，可以看到成功上传的图片，选择相应的图片进行操作即可</p><p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://cdn.jsdelivr.net/gh/rryf/images/posts/20210419133837.png" alt=""></p><h4 id="3-PicGo-注意事项"><a href="#3-PicGo-注意事项" class="headerlink" title="3. PicGo 注意事项"></a>3. PicGo 注意事项</h4><p>如果配置完PicGo后却上传图片失败，可以参考以下方法：</p><ol><li>检查自定义域名是否正确</li><li>仓库名不要有空格</li><li>图片名字不要带有特殊符号，如：%、+、*、空格等</li><li>建议开启时间戳重命名，防止图片名字重复</li><li>上传图片间歇太短，需在PicGo设置中关闭Server选项</li><li>PicGo应用不稳定因素，需重启应用</li></ol><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><ul><li><a href="https://blog.csdn.net/sunhwee/article/details/100109956" target="_blank" rel="noopener">https://blog.csdn.net/sunhwee/article/details/100109956</a></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> BLOG篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PicGo </tag>
            
            <tag> GitHub图床 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
